<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lomse library. API documentation: Rendering documents overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="lomse.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_100x195.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lomse library. API documentation
   &#160;<span id="projectnumber">0.30.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page-render-overview.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Rendering documents overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#mvc-rendering">How to render a document</a></li>
<li class="level1"><a href="#mvc-overview">The Lomse Model-View-Controller</a></li>
<li class="level1"><a href="#rendering-svg">Redering as SVG code</a></li>
<li class="level1"><a href="#rendering-bitmap">Rendering as a bitmap</a></li>
<li class="level1"><a href="#page-render-overview-init-lomse">Lomse library initialization</a></li>
<li class="level1"><a href="#rendering-display">Displaying the document</a></li>
<li class="level1"><a href="#page-render-overview-viewtypes">View types</a></li>
<li class="level1"><a href="#page-render-overview-control">Controlling what is displayed</a></li>
<li class="level1"><a href="#page-render-overview-tips">Tips for several OSs/frameworks</a><ul><li class="level2"><a href="#page-render-overview-qt">Using Lomse in Qt</a></li>
<li class="level2"><a href="#page-render-overview-wxwidgets">Using Lomse in wxWidgets</a></li>
<li class="level2"><a href="#page-render-overview-juce">Using Lomse in JUCE</a></li>
<li class="level2"><a href="#page-render-overview-x11">Using Lomse in X11</a></li>
<li class="level2"><a href="#page-render-overview-windows">Using Lomse in MS Windows</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="mvc-rendering"></a>
How to render a document</h1>
<p>The first and most important thing to learn about Lomse is that is platform independent code, with no knowledge about things such as how to display a document on a window on the screen or how to handle mouse events. Lomse provides the necessary services and interfaces for displaying documents and interacting with them but it is your application responsibility to code the presentation layer, that is the methods and functions for creating windows, handling mouse events, etc., and for requesting Lomse the appropriate services, such as rendering the document in the windows buffer or handling the passed events.</p>
<p>As Lomse aims to be platform independent, it does not use any platform specific graphics interface. Instead it uses an abstract interface class, <a class="el" href="classDrawer.html">Drawer</a>, and implements two specific derived classes, BitmapDrawer and SvgDrawer. But any user application can implement its own drawer classes and do all drawing natively without having to use the drawer classes implemented by Lomse.</p>
<ul>
<li>SvgDrawer is oriented to web and modern UI applications. It renders the document as a stream of SVG commands (as text, in HTML format). And your application should manage this stream as convenient (e.g. inserting it in an HTML page).</li>
<li>BitmapDrawer is oriented to traditional desktop applications. It renders the document on a bitmap, that is, on an array of consecutive memory bytes. This buffer can be any type of memory, such as a real bitmap, a window's buffer, etc. The simplest and usual way of rendering documents on a window is:<ol type="1">
<li>Create a new empty bitmap when necessary (i.e when the window is created or resized),</li>
<li>Ask Lomse to render the desired portion of the document on this bitmap, and</li>
<li>Copy the bitmap onto the window.</li>
</ol>
</li>
</ul>
<p>These operations are usually triggered by your application when handling some operating system events, such as <b>window paint</b> events. Before entering into details it is necessary to understand some important concepts. If you are new to Lomse, <b>please</b> read in sequence this document.</p>
<h1><a class="anchor" id="mvc-overview"></a>
The Lomse Model-View-Controller</h1>
<p>The Model-View-Controller (MVC) is an architecture for providing isolation between the various functions of the GUI: maintaining the document (the Model), displaying all or a portion of the document (the View), and handling events that affect the model or the view(s) (the Controller).</p>
<p>Lomse MVC model has four components: the <code>Model</code> (the document), the <code>View</code> (its visual representation), the <code><a class="el" href="classInteractor.html">Interactor</a></code> (a kind of Controller) and the <code><a class="el" href="classPresenter.html">Presenter</a></code> (the 'glue' to join all the pieces):</p>
<ul>
<li>The Document object (the Model) stores the document content (music scores, paragraphs, images, etc.) and notifies other objects when changes occur to the document.</li>
<li>The View object takes care of rendering the document so that it can be displayed by your application. The View is responsible for providing the rendered document and it is your application responsibility to present this rendered document to the user (i.e. render it on a window, save it in a file, print it, or produce any other desired output). The layout of the rendered document depends on the specific View class used. For instance, class <a class="el" href="classGraphicView.html">GraphicView</a> renders the document as a graphic representation of the document, either as SVG code or as an image on a bitmap. But other classes would be possible (i.e. a view class to render the document as Braille code, a view for rendering as source code, etc.). Currently Lomse has implemented several variations of <a class="el" href="classGraphicView.html">GraphicView</a> such as <a class="el" href="classVerticalBookView.html">VerticalBookView</a>, <a class="el" href="classHorizontalBookView.html">HorizontalBookView</a>, <a class="el" href="classSingleSystemView.html">SingleSystemView</a> and <a class="el" href="classFreeFlowView.html">FreeFlowView</a>. See below.</li>
<li>A Document can have many View objects. For instance, your application can display two windows, one for presenting a music score as a music sheet, and another window for displaying the same music score but as MusicXML source code. This behavior can be achieved by associating two simultaneous views to the document.</li>
<li>The <a class="el" href="classInteractor.html">Interactor</a> object plays the role of the Controller in the MVC model. Each View has an associated Interactor (in fact the View is owned by the Interactor). The Interactor is the interface between your application, the associated View and the Document. It is responsible for translating your application requests into commands that manipulate the associated View and/or the Document, coordinating all the necessary actions.</li>
<li>Finally, the <a class="el" href="classPresenter.html">Presenter</a> object (short for <em>document presenter</em>) is the glue that links all objects in the MVC model. It maintains the life cycle and relationships between Views, Interactors, Commands, Selections, and the Document.</li>
</ul>
<p>The Presenter and most associated objects are created when your application invokes any of the methods in <a class="el" href="classLomseDoorway.html">LomseDoorway</a> for opening/creating documents:</p>
<div class="fragment"><div class="line"><a class="code" href="classLomseDoorway.html">LomseDoorway</a>    m_lomse;</div><div class="line"><a class="code" href="classPresenter.html">Presenter</a>*      m_pPresenter = m_lomse.<a class="code" href="classLomseDoorway.html#af622c7d1c6af2e3394f6a7aaaab51878">new_document</a>(...);</div></div><!-- fragment --><p>Your application will take ownership of the Presenter and will have to delete it when no longer needed. Deleting the Presenter will automatically cause deletion of all MVC involved objects: the Document, all existing Views and their Interactors, selection sets, undo/redo stacks, etc.</p>
<p>By default, when the presented is created, a View and its <a class="el" href="classInteractor.html">Interactor</a> are created. Method <a class="el" href="classPresenter.html#a3542802890a4615d251a5a786cee62b5">Presenter::get_interactor()</a> provides a <a href="https://en.wikipedia.org/wiki/Smart_pointer">smart pointer</a> to the desired Interactor:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (SpInteractor spInteractor = m_pPresenter-&gt;<a class="code" href="classPresenter.html#a3542802890a4615d251a5a786cee62b5">get_interactor</a>(0).lock())</div><div class="line">{</div><div class="line">    <span class="comment">//use the Interactor</span></div><div class="line">    spInteractor-&gt;some_method();</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p>Normally, the Interactor is the only object you would need to use for interacting with the associated View and with the Document.</p>
<h1><a class="anchor" id="rendering-svg"></a>
Redering as SVG code</h1>
<p>The SVG rendering facilities are very simple. It is basically opening a document and requesting its rendition. The View will render the document on a std::ostream that your application must provide, and once Lomse has generated the SVG code, it is your application responsibility to do whatever is needed with that code: injecting it in an HTML page and displaying it on a browser window embedded into your application, exporting it as an image file, etc. For instance:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;lomse_doorway.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;lomse_graphic_view.h&gt;</span>     <span class="comment">//for view types</span></div><div class="line"><span class="preprocessor">#include &lt;lomse_interactor.h&gt;</span>       <span class="comment">//Interactor</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacelomse.html">lomse</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">//create the instance of the library doorway</span></div><div class="line">    lomse::LomseDoorway <a class="code" href="namespacelomse.html">lomse</a>;</div><div class="line"></div><div class="line">    <span class="comment">//open an score</span></div><div class="line">    lomse::Presenter* pPresenter = </div><div class="line">        lomse.open_document(k_view_vertical_book,</div><div class="line">                            <span class="stringliteral">&quot;&lt;path&gt;/&lt;to&gt;/&lt;the&gt;/MusicXMLscore.xml&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (SpInteractor spInteractor = pPresenter-&gt;get_interactor(0).lock())</div><div class="line">    {</div><div class="line">        <span class="comment">//generate the SVG rendition for the first page</span></div><div class="line">        std::stringstream svg;</div><div class="line">        <span class="keywordtype">int</span> page = 0;</div><div class="line">        pIntor-&gt;svg_add_newlines(<span class="keyword">true</span>);     <span class="comment">//for human legibility</span></div><div class="line">        spInteractor-&gt;render_as_svg(svg, page);</div><div class="line"></div><div class="line">        <span class="comment">//do whatever you like with the svg code</span></div><div class="line">        cout &lt;&lt; svg.str() &lt;&lt; endl;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Could not open document!&quot;</span> &lt;&lt; endl;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">delete</span> pPresenter;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>See <a class="el" href="page-render-svg.html">Render in SVG format</a> for details</p>
<h1><a class="anchor" id="rendering-bitmap"></a>
Rendering as a bitmap</h1>
<p>The Lomse facilities for rendering on a bitmap are oriented to traditional desktop applications. The View renders the document on a memory buffer that your application must provide. Once Lomse has rendered the document on this bitmap buffer, it is your application responsibility to do whatever is needed with the bitmap: rendering it on a window, exporting it as a file, printing it, etc.</p>
<p>Once the View is created (remember that it is created automatically when your application invokes any of the methods in <a class="el" href="classLomseDoorway.html">LomseDoorway</a> for opening/creating documents), and before processing any paint event, it is necessary to inform Lomse about the rendering buffer to use. The memory for this buffer must be allocated when necessary, normally when the window is created and each time it is resized. Therefore, the event handler for <b>window resize</b> events is, usually, the best place for allocating memory for the buffer and informing Lomse about the new buffer:</p>
<div class="fragment"><div class="line"><span class="comment">//some MyWindow class member variables:</span></div><div class="line"><a class="code" href="classLomseDoorway.html">LomseDoorway</a>&amp;       m_lomse;            <span class="comment">//the Lomse library doorway</span></div><div class="line"><a class="code" href="classPresenter.html">Presenter</a>*          m_pPresenter;       <span class="comment">//the Presenter for this window</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*      m_pBuffer;          <span class="comment">//ptr to the bitmap memory</span></div><div class="line"><span class="keywordtype">bool</span>                m_renderView;       <span class="comment">//the score needs to be rendered on the bitmap</span></div><div class="line"></div><div class="line">MyWindow::MyWindow(<a class="code" href="classLomseDoorway.html">LomseDoorway</a>&amp; lomse)</div><div class="line">    : m_lomse(lomse)</div><div class="line">    , m_pPresenter(nullptr)</div><div class="line">    , m_pBuffer(nullptr)</div><div class="line">    , m_renderView(false)</div><div class="line">{</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> MyWindow::on_new_document()</div><div class="line"></div><div class="line">{</div><div class="line">    <span class="keyword">delete</span> m_pPresenter;</div><div class="line">    m_pPresenter = m_lomse.<a class="code" href="classLomseDoorway.html#af622c7d1c6af2e3394f6a7aaaab51878">new_document</a>(....);</div><div class="line">    <span class="keywordflow">if</span> (!m_pBuffer)</div><div class="line">        create_rendering_buffer();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> MyWindow::handle_resize_event()</div><div class="line">{</div><div class="line">    create_rendering_buffer();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> MyWindow::create_rendering_buffer()</div><div class="line"></div><div class="line">{</div><div class="line">    <span class="comment">//determine current window size</span></div><div class="line">    <span class="keywordtype">int</span> width = ...</div><div class="line">    <span class="keywordtype">int</span> height = ...</div><div class="line"></div><div class="line">    <span class="comment">//create a new bitmap for the rendering buffer.</span></div><div class="line">    <span class="keyword">delete</span> m_pBuffer;</div><div class="line">    m_pBuffer = ...   <span class="comment">//many possibilities for allocating memory or reusing memory</span></div><div class="line"></div><div class="line">    <span class="comment">//use this bitmap as Lomse rendering buffer</span></div><div class="line">    <span class="keywordflow">if</span> (m_pPresenter)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (SpInteractor spInteractor = m_pPresenter-&gt;<a class="code" href="classPresenter.html#a3542802890a4615d251a5a786cee62b5">get_interactor</a>(0).lock())</div><div class="line">            spInteractor-&gt;set_rendering_buffer(m_pBuffer, width, height);</div><div class="line">    </div><div class="line">        m_renderView = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Probably you have noticed that the format of the bitmap (i.e., bytes per pixel, byte ordering, etc.) has not been specified in previous code. The place for doing it is at Lomse library initialization (see next section).</p>
<p>Deciding the how to allocate memory for the rendering buffer and the bitmap format to use are the most critical decisions when using Lomse. Depending on your application operating system and on the application framework used for coding it, the solution is different.</p>
<h1><a class="anchor" id="page-render-overview-init-lomse"></a>
Lomse library initialization</h1>
<p>The first step is to include the needed headers. At the time of writing this the Lomse API is not yet fixed; therefore there is not a single header file (or set of headers) to include. Instead, the headers to include will depend on the classes and functions you would like to use. Anyway, with current API you will always include:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;lomse_doorway.h&gt;</span></div><div class="line"><span class="keyword">using namespace </span>Lomse;</div></div><!-- fragment --><p>The <a class="el" href="classLomseDoorway.html">LomseDoorway</a> object is the access point to the Lomse library and the main interface with the library. It must be used by your application at two points:</p>
<ol type="1">
<li>Before using the Lomse library it is necessary to initialize it. This means setting up certain global options about rendering and events handling.</li>
<li>Later, your application has to use it for:<ul>
<li>Opening and creating Document objects.</li>
<li>Accessing global objects and variables in Lomse library.</li>
</ul>
</li>
</ol>
<p>You need to define and create an instance of <a class="el" href="classLomseDoorway.html">LomseDoorway</a>, usually with global scope:</p>
<div class="fragment"><div class="line"><a class="code" href="classLomseDoorway.html">LomseDoorway</a>   m_lomse;        <span class="comment">//the Lomse library doorway</span></div></div><!-- fragment --><p>For rendering on bitmaps, the most important aspect to consider to initialize Lomse is the format of the images to be generated:</p>
<ol type="1">
<li>the bitmap format to use, and</li>
<li>the resolution to use (pixels per inch)</li>
</ol>
<p>But if your application will render only SVG code, these values are irrelevant and initialization is not necessary.</p>
<p>For rendering on bitmaps, the <b>most important</b> decision is how your application will allocate memory for the rendering buffer and the bitmap format to use, and how this bitmap will be rendered (or converted to a image format to be exported to a file or embedded in a document). Depending on your application operating system and on the application framework used for coding it, the solution is different. You should take these decisions by analyzing the most convenient and fast method for rendering the bitmaps and to avoid format conversions. Sometimes the options are very limited.</p>
<p>Once you have decided the most suitable bitmap format to use, the next parameter to decide is the intended screen resolution. This value is not important because Lomse uses vectorial graphics for all, typography included and, thus, your application can always scale the image to as much resolution as you like. Nevertheless, Lomse requires a screen resolution value to adjust internal scaling factors so that when your application sets the scale to 1.0 (100%) the document get displayed on the screen at real size. If this is not a requirement for your application, any typical value can be used (e.g. 72, 96, 144, ...). Otherwise, probably you should get this value by invoking some operating system related methods (i.e. wxDC::GetPPI() method, in wxWidgets framework).</p>
<p>With this, we can proceed to initialize Lomse. Here is the full code:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyApp::initialize_lomse()</div><div class="line">{</div><div class="line">    <span class="comment">//the pixel format, e.g.: ARGB 32bits</span></div><div class="line">    <span class="keywordtype">int</span> pixel_format = <a class="code" href="group__enumerations.html#ggafb559e26bc610db43ba605230a142898a115170a7630e87bdb0d90728b79c1e4e">k_pix_format_argb32</a>;</div><div class="line"></div><div class="line">    <span class="comment">//the desired resolution, e.g.: 96 pixels per inch</span></div><div class="line">    <span class="keywordtype">int</span> resolution = 96;</div><div class="line"></div><div class="line">    <span class="comment">//initialize the library with these values</span></div><div class="line">    m_lomse.<a class="code" href="classLomseDoorway.html#af65c535236e088710cf055c9180f34fa">init_library</a>(pixel_format, resolution);</div><div class="line">}</div></div><!-- fragment --><dl class="section attention"><dt>Attention</dt><dd>Library initialization is not necessary if your application will not use Lomse to render scores in bitmaps, e.g.: uses it only for playback or only renders SVG code. In these cases any values for pixel format and resolution will be valid and so, default values are enough and you will not have to invoke the init_library() method.</dd></dl>
<p>At end of this chapter there are summary cards with information about using Lomse in different frameworks and operating systems. See page <a class="el" href="page-examples.html">Tutorials and samples</a> for full application code samples.</p>
<h1><a class="anchor" id="rendering-display"></a>
Displaying the document</h1>
<p>Once a document is open and the rendering buffer for the View is created, all your application has to do is to:</p><ol type="1">
<li>ask Lomse to render the desired portion of the document on the rendering buffer, and</li>
<li>copy the rendered bitmap onto the window.</li>
</ol>
<p>These operations are usually triggered in the handler for <b>window paint</b> events. Notice that there is no need to ask Lomse to paint the bitmap whenever a paint event arrives. These events are generated due to different reasons. The most frequent is when the window image is damaged (i.e. another window that was covering our window has moved). But in these cases the image is preserved in the bitmap so it is enough to re-display the bitmap. Other cases for receiving paint events are because the window has changed: when the window is created or when it is resized or when your application changes its content (i.e. because the user has open a different document). Flag <em>m_renderView</em> is defined in your application for controlling the need to repaint the buffer: do it only when the repaint event is caused by a window resize or because the application has changed the content of the document; otherwise the Lomse buffer is still valid and you can save time by skipping to ask Lomse for a repaint:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyWindow::handle_paint_event(DeviceContext* paintDC)</div><div class="line">{</div><div class="line">    <span class="comment">//ensure that the bitmap has the right content or repaint it</span></div><div class="line">    update_rendering_buffer_if_needed();</div><div class="line"></div><div class="line">    <span class="comment">//copy the bitmap to the window.</span></div><div class="line">    <span class="comment">//AWARE: Platform dependent code. This is just an example </span></div><div class="line">    <span class="comment">//       using generic methods. Adapt this code before using</span></div><div class="line">    <span class="comment">//       it in a real application.</span></div><div class="line">    paintDC-&gt;BeginPaint();</div><div class="line">    paintDC-&gt;DrawBitmap(m_pBuffer, ...);</div><div class="line">    paintDC-&gt;EndPaint();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> MyWindow::update_rendering_buffer_if_needed()</div><div class="line">{</div><div class="line">    <span class="comment">//request Lomse to re-draw the bitmap</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (m_pPresenter != <span class="keyword">nullptr</span> &amp;&amp; m_renderView)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (SpInteractor spInteractor = m_pPresenter-&gt;<a class="code" href="classPresenter.html#a3542802890a4615d251a5a786cee62b5">get_interactor</a>(0).lock())</div><div class="line">            spInteractor-&gt;force_redraw();</div><div class="line">        m_renderView = <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="page-render-overview-viewtypes"></a>
View types</h1>
<p>As said, Lomse uses a Model-View-Controller architecture. This means that, internally, Lomse maintains a graphic representation of the document defined by the chosen view type. Lomse has several view types:</p>
<p><b>Vertical Book View</b>. View type <em>k_view_vertical_book</em> is a view oriented to display the document in pages, with the pages spread in vertical, one page after the other in a vertical layout. The user will have to scroll down for advancing. This is the typical view used in e.g. Adobe PDF Reader and MS Word.</p>
<div class="image">
<img src="view-vertical-book.png" alt="view-vertical-book.png"/>
<div class="caption">
Image: The 'real world' when using a 'k_view_vertical_book' View</div></div>
<p><b>Horizontal Book View</b>. View type <em>k_view_horizontal_book</em> means that the document will be displayed in pages, with the pages spread in horizontal, one page after the other in a horizontal layout. The user will have to scroll right for advancing. This is the typical view used to display scores in e.g. Finale or Sibelius.</p>
<div class="image">
<img src="view-horizontal-book.png" alt="view-horizontal-book.png"/>
<div class="caption">
Image: The 'real world' when using a 'k_view_horizontal_book' View</div></div>
<p><b>Single System View</b>. View type <em>k_view_single_system</em> is for rendering documents that only contain one score (e.g. LDP files, LMD files with just one score, and score files imported from other formats such as MusicXML). It will display the score in a single system, as if the paper had infinite width. And for viewing the end of the score the user will have to scroll to the right.</p>
<div class="image">
<img src="view-single-system.png" alt="view-single-system.png"/>
<div class="caption">
Image: The 'real world' when using a 'k_view_single_system' View</div></div>
<p><b>Single Page View</b>. View type <em>k_view_single_page</em> is similar to an HTML page having a body of fixed width. All the document is rendered in a single page having the required height to contain the full document. Is a kind of k_view_vertical_book but without gaps in the content for separating pages. As with k_view_vertical_book the user will have to scroll down for advancing.</p>
<div class="image">
<img src="view-single-page.png" alt="view-single-page.png"/>
<div class="caption">
Image: The 'real world' when using a 'k_view_single_page' View</div></div>
<p><b>Free Flow View</b>. View type <em>k_view_free_flow</em> is for rendering documents in a single page as high as necessary and as wide as the rendering window. It is similar to an HTML page with unconstrained body width.</p>
<div class="image">
<img src="view-free-flow.png" alt="view-free-flow.png"/>
<div class="caption">
Image: The 'real world' when using a 'k_view_free_flow' View</div></div>
<p><b>Half Page View</b>. View type <em>k_view_half_page</em> has a double behavior. In normal mode (no playback) it behaves as <a class="el" href="classSinglePageView.html">SinglePageView</a>, that is the score is rendered on a single page as high as necessary to contain all the score (e.g., an HTML page having a body of fixed size). But when in playback mode, the bitmap to be rendered in the application window is split horizontally in two halves, originating two virtual vertical windows, one at top and the other at bottom. This view allows to solve the problem page turning and the problem of repetition marks and jumps during playback. See <a class="el" href="classHalfPageView.html">HalfPageView</a> for more details.</p>
<h1><a class="anchor" id="page-render-overview-control"></a>
Controlling what is displayed</h1>
<p>When Lomse renders the document, it uses a graphic representation of the document defined by the chosen view type. When requesting Lomse to render the document onto your application window it is not expected that Lomse will squeeze all the document pages into that window, but just the specific part of the document that the user wants to visualize, as it is expected that the users can pan and zoom to see different areas of the document.</p>
<p>The portion of the document that is rendered on the bitmap is controlled by the viewport and the scale that your application defines (see <a class="el" href="page-coordinates-viewport.html">Coordinate systems, units, scaling and viewport</a>). Initially, the viewport is set at the top left corner of the view, and it width and height is defined by the bitmap size, scaled by the current scaling factor (initially 1.0).</p>
<div class="image">
<img src="viewport.png" alt="viewport.png"/>
<div class="caption">
Image: The 'viewport' and the 'device window'</div></div>
<p>Your application can use Interactor specific methods for changing the viewport so that the user can choose what to display and to implement scrolling. See: <a class="el" href="classInteractor.html#a0eb3195aed54028cc3f250c38029e8f8">Interactor::new_viewport()</a>, <a class="el" href="classInteractor.html#a81455e8a584d8dff982c3f43e92e7f34">Interactor::set_viewport_at_page_center()</a>, <a class="el" href="classInteractor.html#afc7dac3c7d8b7d629f38b79750e34905">Interactor::get_viewport()</a>, <a class="el" href="classInteractor.html#a331181fe34d2f9399578bbe4be3f5f65">Interactor::get_view_size()</a>.</p>
<p>Also there are methods for adjusting the scaling factor, so that the user can zoom in and out, or adjust the scale so that a whole page fits in the display. See: <a class="el" href="classInteractor.html#ad79a50661807b829755219e4bdf21121">Interactor::get_scale()</a>, <a class="el" href="classInteractor.html#a5e7dbf2be635475f40ba9b723a902d37">Interactor::set_scale()</a>, <a class="el" href="classInteractor.html#a4ec8ec1d6b84a74d656f2773c741e222">Interactor::zoom_in()</a>, <a class="el" href="classInteractor.html#a6fc96dec0a3767152cd953d2ec68ec96">Interactor::zoom_out()</a>, <a class="el" href="classInteractor.html#ac83345221209221be48169f01a4cd253">Interactor::zoom_fit_full()</a>, <a class="el" href="classInteractor.html#a8d486a75231279d13370cb9744f8cf11">Interactor::zoom_fit_width()</a>.</p>
<p>As these concepts are common and widely used in computer graphics theory, I will not enter here into more details, but your application have full control of what to render on the bitmap passed to Lomse as rendering buffer.</p>
<p>You have also the possibility of defining a view clip area so that only part of the passed rendering buffer will be used by Lomse. See <a class="el" href="classInteractor.html#a02d56322c7d65b7faf7bb3be1d2bde4b">Interactor::set_view_area()</a>.</p>
<h1><a class="anchor" id="page-render-overview-tips"></a>
Tips for several OSs/frameworks</h1>
<p>Here you can find summary cards with information about using Lomse in different frameworks and operating systems. See page <a class="el" href="page-examples.html">Tutorials and samples</a> for full application code samples. I would appreciate if you could help me to improve this documentation. Open an issue in lomse repo or send a PR (the source of this document is at 'lomse/docs/api/mainpages/render-overview.h'). Thank you.</p>
<h2><a class="anchor" id="page-render-overview-qt"></a>
Using Lomse in Qt</h2>
<p>Qt is a free and open-source widget toolkit for creating graphical user interfaces as well as cross-platform applications that run on various software and hardware platforms such as Linux, Windows, macOS, Android or embedded systems. Looking at Qt documentation, it seems that to render an image on screen, a good approach is to use a QImage object as it can be created from a raw bitmap without the need of image format conversions if we choose the right format. To render on screen I have tested bitmaps in RGBA, 32 bits format (Lomse format k_pix_format_rgba32). This is a summary:</p>
<div class="fragment"><div class="line">Application framework:  Qt</div><div class="line">Operating system:       any</div><div class="line"></div><div class="line">Lomse library initialization</div><div class="line">---------------------------------------</div><div class="line">    <span class="comment">//Resolution: 96 pixels per inch</span></div><div class="line">    <span class="keywordtype">int</span> resolution = 96;</div><div class="line">    </div><div class="line">    <span class="comment">//pixel format RGBA, 32 bits </span></div><div class="line">    <span class="keywordtype">int</span> pixel_format = <a class="code" href="group__enumerations.html#ggafb559e26bc610db43ba605230a142898ad6396874d1012fad53ebaff1393c8df8">k_pix_format_rgba32</a>;</div><div class="line"></div><div class="line">    <span class="comment">//initialize the Lomse library with these values</span></div><div class="line">    m_lomse.<a class="code" href="classLomseDoorway.html#af65c535236e088710cf055c9180f34fa">init_library</a>(pixel_format, resolution);</div><div class="line"></div><div class="line"></div><div class="line">Creating the rendering buffer</div><div class="line">------------------------------</div><div class="line">    <span class="comment">//Memory for the bitmap:    just raw memory</span></div><div class="line">    <span class="comment">//Object to manage it:      QImage,  Format_RGBA8888</span></div><div class="line"></div><div class="line"><span class="preprocessor">    #define BYTES_PER_PIXEL 4       //using RGBA, 32 bits </span></div><div class="line">    m_pdata = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)malloc(width * height * BYTES_PER_PIXEL);</div><div class="line"></div><div class="line"></div><div class="line">Paint <span class="keyword">event</span></div><div class="line">-----------------</div><div class="line"><span class="keywordtype">void</span> MyWindow::paintEvent(QPaintEvent* event)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (m_presenter &amp;&amp; m_pdata)</div><div class="line">    {</div><div class="line">        QPainter painter(<span class="keyword">this</span>);</div><div class="line">        QImage image(m_pdata, m_bufWidth, m_bufHeight, QImage::Format_RGBA8888);</div><div class="line">        QRect dirtyRect = <span class="keyword">event</span>-&gt;rect();</div><div class="line">        painter.drawImage(dirtyRect, image, dirtyRect);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="page-render-overview-wxwidgets"></a>
Using Lomse in wxWidgets</h2>
<p>wxWidgets is a free and open-source widget toolkit for creating graphical user interfaces as well as cross-platform applications that run on Linux, Windows, and macOS. For wxWidgets applications I've found that using a wxImage as bitmap buffer is a good strategy, as <code>wxImage</code> is a platform independent class and contains a buffer for a bitmap in RGB, 24 bits format. This is a summary of how to use:</p>
<div class="fragment"><div class="line">Application framework:  wxWidgets</div><div class="line">Operating system:       any</div><div class="line"></div><div class="line">Lomse library initialization</div><div class="line">---------------------------------------</div><div class="line">    <span class="comment">//Resolution: 96 pixels per inch, or use wxDC::GetPPI() to get it</span></div><div class="line">    <span class="keywordtype">int</span> resolution = 96;</div><div class="line">    </div><div class="line">    <span class="comment">//pixel format RGB 24bits </span></div><div class="line">    <span class="keywordtype">int</span> pixel_format = <a class="code" href="group__enumerations.html#ggafb559e26bc610db43ba605230a142898a048c5c0cc2b0abf5dc1b0354b6ea0005">k_pix_format_rgb24</a>;</div><div class="line"></div><div class="line">    <span class="comment">//initialize the Lomse library with these values</span></div><div class="line">    m_lomse.<a class="code" href="classLomseDoorway.html#af65c535236e088710cf055c9180f34fa">init_library</a>(pixel_format, resolution);</div><div class="line"></div><div class="line"></div><div class="line">Creating the rendering buffer</div><div class="line">------------------------------</div><div class="line">    <span class="comment">//Memory for the bitmap:    the internal bitmap of a wxImage</span></div><div class="line">    <span class="comment">//Object to manage it:      wxImage</span></div><div class="line"></div><div class="line">    <span class="comment">// allocate a new rendering buffer</span></div><div class="line">    <span class="keyword">delete</span> m_buffer;</div><div class="line">    m_buffer = <span class="keyword">new</span> wxImage(width, height);</div><div class="line"></div><div class="line"></div><div class="line">Paint <span class="keyword">event</span></div><div class="line">-----------------</div><div class="line"><span class="keywordtype">void</span> MyWindow::paintEvent(wxPaintEvent&amp; event)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (m_presenter &amp;&amp; m_buffer)</div><div class="line">    {</div><div class="line">        wxPaintDC dc(<span class="keyword">this</span>);</div><div class="line">        wxBitmap bitmap(*m_buffer);</div><div class="line">        dc.DrawBitmap(bitmap, 0, 0, <span class="keyword">false</span>); <span class="comment">//false = don&#39;t use mask</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="page-render-overview-juce"></a>
Using Lomse in JUCE</h2>
<p>JUCE is a partially open-source cross-platform C++ application framework, used for the development of desktop and mobile applications that run on various software and hardware platforms such as Linux, Windows, macOS and Android. I have not tested it but Lomse users report that the following configuration works well:</p>
<div class="fragment"><div class="line">Application framework:  JUCE</div><div class="line">Operating system:       any</div><div class="line"></div><div class="line">Lomse library initialization</div><div class="line">---------------------------------------</div><div class="line">    <span class="comment">//Resolution: 96 * UI scale</span></div><div class="line">    m_scale = m_settings.zoomUi * Desktop::getInstance().getDisplays().getMainDisplay().scale;</div><div class="line">    <span class="keywordtype">int</span> resolution = int(96 * m_scale);</div><div class="line">    </div><div class="line">    <span class="comment">//pixel format</span></div><div class="line">    <span class="keywordtype">int</span> pixel_format = <a class="code" href="group__enumerations.html#ggafb559e26bc610db43ba605230a142898ad6396874d1012fad53ebaff1393c8df8">k_pix_format_rgba32</a>;</div><div class="line"></div><div class="line">    <span class="comment">//initialize the Lomse library with these values</span></div><div class="line">    m_lomse.<a class="code" href="classLomseDoorway.html#af65c535236e088710cf055c9180f34fa">init_library</a>(pixel_format, resolution);</div><div class="line"></div><div class="line"></div><div class="line">Creating the rendering buffer</div><div class="line">------------------------------</div><div class="line">    <span class="comment">//Memory for the bitmap:    juce::Image internal BitmapData</span></div><div class="line">    <span class="comment">//Object to manage it:      juce::Image,  PixelFormat::ARGB</span></div><div class="line"></div><div class="line">    <span class="comment">//create image</span></div><div class="line">    m_image.reset(<span class="keyword">new</span> juce::Image(juce::Image::PixelFormat::ARGB, width, height,</div><div class="line">                                  <span class="keyword">false</span>, SoftwareImageType()));</div><div class="line">        </div><div class="line">    <span class="comment">//creates a bitmap of specified size</span></div><div class="line">    juce::Image::BitmapData bitmap(*m_image, juce::Image::BitmapData::readWrite);</div><div class="line"></div><div class="line"></div><div class="line">Paint <span class="keyword">event</span></div><div class="line">-----------------</div><div class="line"><span class="keywordtype">void</span> MyWindow::paint(Graphics&amp; g)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (m_presenter &amp;&amp; m_image)</div><div class="line">    {</div><div class="line">        g.drawImage(*m_image, 0, 0, getWidth(), getHeight(), 0, 0, m_image-&gt;getWidth(), m_image-&gt;getHeight());</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        String text = <span class="stringliteral">&quot;Some error message&quot;</span>;</div><div class="line">        juce::Rectangle&lt;int&gt; rec(20, 80, getWidth() - 40, getHeight() - 100);</div><div class="line">        g.drawFittedText(text, rec, Justification::centredTop, 100, 1);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="page-render-overview-x11"></a>
Using Lomse in X11</h2>
<p>The X Window System (X11, or simply X) is a windowing system for bitmap displays, common on Unix-like operating systems. To decide which bitmap format we are going to use it is possible to choose a common, widely supported format, such as bitmaps in RGBA format, 8 bits per pixel. But for your convenience, the code in tutorial-1-x11 includes a function "determine_suitable_bitmap_format()" for selecting a suitable bitmap format by determining the available X11 Visuals. This function has been borrowed from examples in AGG project and sets global variables <em>m_depth</em> (the color depth to use), <em>m_visual</em> (the X11 Visual to use), <em>m_format</em> (a Lomse enum describing the bitmap format) and <em>m_byte_order</em> (the endian or byte ordering for this platform).</p>
<div class="fragment"><div class="line">Framework:          The X Window System (X11)</div><div class="line">Operating system:   Unix-like operating systems</div><div class="line"></div><div class="line">Lomse library initialization</div><div class="line">---------------------------------------</div><div class="line">    <span class="comment">//Resolution: 96 pixels per inch, or use wxDC::GetPPI() to get it</span></div><div class="line">    <span class="keywordtype">int</span> resolution = 96;</div><div class="line">    </div><div class="line">    <span class="comment">//pixel format: choose one from the available X11 Visuals</span></div><div class="line">    determine_suitable_bitmap_format();</div><div class="line">    <span class="keywordtype">int</span> pixel_format = m_format;</div><div class="line"></div><div class="line">    <span class="comment">//initialize the Lomse library with these values</span></div><div class="line">    m_lomse.<a class="code" href="classLomseDoorway.html#af65c535236e088710cf055c9180f34fa">init_library</a>(pixel_format, resolution);</div><div class="line"></div><div class="line"></div><div class="line">Creating the rendering buffer</div><div class="line">------------------------------</div><div class="line">    <span class="comment">//Memory for the bitmap:    just raw memory</span></div><div class="line">    <span class="comment">//Object to manage it:      XImage</span></div><div class="line"></div><div class="line">    <span class="comment">//allocate memory for the bitmap, fill it with 1&#39;s</span></div><div class="line">    m_buffer = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[width * height * (m_bpp / 8)];</div><div class="line">    memset(m_buffer, 255, width * height * (m_bpp / 8));</div><div class="line"></div><div class="line">    <span class="comment">//create an X11 image using the allocated memory as buffer</span></div><div class="line">    m_ximg = XCreateImage(m_pDisplay,</div><div class="line">                          m_visual,</div><div class="line">                          m_depth,</div><div class="line">                          ZPixmap,</div><div class="line">                          0,</div><div class="line">                          (<span class="keywordtype">char</span>*)m_buffer,</div><div class="line">                          width,</div><div class="line">                          height,</div><div class="line">                          m_bpp,</div><div class="line">                          width * (m_bpp / 8)</div><div class="line">                        );</div><div class="line">    m_ximg-&gt;byte_order = m_byte_order;</div><div class="line"></div><div class="line"></div><div class="line">Paint <span class="keyword">event</span></div><div class="line">-----------------</div><div class="line">    <span class="comment">//copy the view bitmap onto the image</span></div><div class="line">    m_ximg-&gt;data = (<span class="keywordtype">char</span>*)m_buffer;</div><div class="line"></div><div class="line">    <span class="comment">//display the image</span></div><div class="line">    XPutImage(m_pDisplay,</div><div class="line">              m_window,</div><div class="line">              m_gc,</div><div class="line">              m_ximg,</div><div class="line">              0, 0, 0, 0,</div><div class="line">              rbuf-&gt;width(),</div><div class="line">              rbuf-&gt;height()</div><div class="line">             );</div><div class="line">    XSync(m_pDisplay, <span class="keyword">false</span>);</div></div><!-- fragment --><h2><a class="anchor" id="page-render-overview-windows"></a>
Using Lomse in MS Windows</h2>
<p>My knowledge of using the Microsoft Windows API is nullptr. In other platforms normally your application uses one of the available image objects. Although the Windows API provides many functions for creating and managing bitmaps, as my lack of knowledge about Windows, I opted to to some tests by borrowing code from the AGG project, instead of finding documentation and studying how to use the Windows API functions. So, I choose to create a <code>Bitmap</code> class, enclosing the necessary methods and knowledge in it. See tutorial 1 for Windows. If you have good knowledge of the Windows API probably you would prefer a different solution for managing bitmaps. In that case, I would appreciate if you could help me to improve this documentation. Open an issue in lomse repo or send a PR (the source of this document is at 'lomse/docs/api/mainpages/render-overview.h'). Thank you. This is a summary of how I used it in the tutorials and samples:</p>
<div class="fragment"><div class="line">Operating system:       Microsoft Windows</div><div class="line">Memory <span class="keywordflow">for</span> the bitmap:  ad-hoc bitmap <span class="keyword">class</span> (see code in tutorial-1-win)</div><div class="line"></div><div class="line"></div><div class="line">Lomse library initialization</div><div class="line">---------------------------------------</div><div class="line">    <span class="comment">//Resolution: 96 pixels per inch</span></div><div class="line">    <span class="keywordtype">int</span> resolution = 96;</div><div class="line">    </div><div class="line">    <span class="comment">//pixel format BGRA, 32 bits</span></div><div class="line">    <span class="keywordtype">int</span> pixel_format = <a class="code" href="group__enumerations.html#ggafb559e26bc610db43ba605230a142898acbfd950e1ef577e4a697ad2dadd30ec7">k_pix_format_bgra32</a>;</div><div class="line"></div><div class="line">    <span class="comment">//initialize the Lomse library with these values</span></div><div class="line">    m_lomse.<a class="code" href="classLomseDoorway.html#af65c535236e088710cf055c9180f34fa">init_library</a>(pixel_format, resolution);</div><div class="line"></div><div class="line"></div><div class="line">Creating the rendering buffer</div><div class="line">------------------------------</div><div class="line">    <span class="comment">//Memory for the bitmap:    just raw memory. Allocated in ad-hoc Bitmap class</span></div><div class="line">    <span class="comment">//Object to manage it:      ad-hoc Bitmap class</span></div><div class="line"></div><div class="line">    m_bitmap.create(width, height, m_bpp);</div><div class="line"></div><div class="line"></div><div class="line">Paint <span class="keyword">event</span></div><div class="line">-----------------</div><div class="line">    <span class="keywordflow">case</span> WM_PAINT:</div><div class="line">    {</div><div class="line">        update_rendering_buffer_if_needed();</div><div class="line"></div><div class="line">        PAINTSTRUCT ps;</div><div class="line">        HDC paintDC = ::BeginPaint(m_hWnd, &amp;ps);</div><div class="line">        m_bitmap.draw(paintDC);</div><div class="line">        ::EndPaint(m_hWnd, &amp;ps);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    }</div></div><!-- fragment --><p>Please help me to improve this documentation and to add information for other platforms and operating systems. Open an issue in lomse repo or send a PR (the source of this document is at 'lomse/docs/api/mainpages/render-overview.h'. Thank you. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Overview</a></li>
    <li class="footer">Generated on Tue Oct 25 2022 19:12:48 for Lomse library. API documentation by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
